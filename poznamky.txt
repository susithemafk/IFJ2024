Používejte Linux nebo WSL pro překlad.

Semantika, conversion rules

# they will be testing mainly releations operands conversions see -> https://moodle.vut.cz/mod/page/view.php?id=458178

General rule:

Constant expression with known value at compile time of type f64 can be converted to i32
    - examples of constant expressions (f64 only): 
        . const a = 3.14, (cannot be converted to i32) # this is wierd as heck, that you can do this, but they mention it here -> https://moodle.vut.cz/mod/forum/discuss.php?d=4850
        . const a = 3.0 (can be converted to i32)
        3.14 (cannot be coverted to i32)
        3.0 (can be converted to i32)
    - example of what is NOT an constant expresion (f64 only): 
        . const a = 3.14 # this is const, exp.
        . const b = a + 4 # the value of this is not known at compile time
        . const a = 3.0 * 3 
        . const a = 3.0 * 3.1

Arithmetic operations:
+ - *  (A opr B)

Not allowed: (Incompatable types) 
#note, in semantical Analysis, we check the conditions bellow first, if anyone of them is met
A.nullble == true || B.nullable == true #since once cannot add "null" to something
A.type not in (i32, f64) || B.type not in (i32, f64)
A == "null" or B == "null"

Allowed: 
A.type == B.type -> (SUCESS)

A is i32 literal && B is f64 literal -> (convert A to f64, SUCESS) 
A is f64 literal && B is i32 literal -> (convert B to f64,  SUCESS)

A is f64 variable && B is i32 literal 
    -> (convert B to f64, SUCESS)

A is i32 literal && B is f64 variable
    -> (convert A to f64, SUCESS)

A is i32 variable && B is f64 literal 
    -> (if decimal place of B is only 0s, we convert B to i32 -> SUCESS, else ERROR)

A is f64 literal && A is i32 variable
    -> (if decimal place of A is only 0s, we convert A to i32 -> SUCESS, else ERROR)

A is constant f64 expresion (value known at compile time) && B is I32 variable (not constant, value not known at compile time) 
    -> (if deciaml place of A is only 0s, we convert A to i32 -> SUCCESS, else ERROR)

A is i32 variable (not constant, value not known at compile time) && B is constant f64 expresion (value known at compile time)
    -> (if deciaml place of B is only 0s, we convert B to i32 -> SUCCESS, else ERROR)

A is constant f64 expression (value known at compile time) && B is i32 literal
    -> (convert B to f64 -> SUCCESS)

A is I32 literal && B is constant f64 expression (value known at compile time)
    -> (convert A to f64 -> SUCCESS)

else:
    ERROR

/ (A / B)

Allowed:

1st, sanity check:
A.nullble == true || B.nullable == true #since once cannot add "null" to something
A.type not in (i32, f64) || B.type not in (i32, f64)
A == "null" or B == "null"
B == 0 || B == 0.0 (even if the value of B is known at compile time, need to check this)

A.type == B.type -> SUCCESS

A is constant f64 expression (value known at compile time) && B is i32 (any type: literal, variable, bianry expression ...)
    -> (if decimal place of A is only 0s, we convert A to i32 -> SUCESS else ERROR)

A is i32 (any type: literal, variable, bianry expression ...) && B is a constant f64 expression (value known at compile time)
    -> (if decimal place of B is only 0s, we convert B to i32 -> SUCCESS else ERROR)

else:
    ERROR

Relational operands

== != (A opr B)

1st, handeling of one side or both being "null"

Allowed
A == "null" && B == "null" -> SUCCESS
(A.nullable == true && B == "null") || (A == "null" && B.nullable == true) 
    -> SUCESS

Not allowed:
(A.nullable == false && B == "null") || (A == "null" && B.nullable == false) 
    -> ERROR

2nd, handeling of types

Allowed

A.type == B.type -> SUCESS

A is variable i32 && B is f64 literal
    -> (if deciaml place of B is 0s, convert B f64 -> SUCESS, else ERROR)

A is f64 literal && B is i32 variable
    -> (if decimal place of A is 0s, convert A f64 -> SUCCESS, else ERROR)

A is variable f64 && B is i32 literal
    -> (Convert B to f64 -> SUCCESS)

A is i32 literal && B is variable f64
    -> (Convert A to f64 -> SUCCESS)

A is f64 constant expresion (value known at compile time) && B is i32 variable
    -> (if decimal place of A is 0s, convert A i32, SUCCESS, else -> ERROR)

A is i32 variable && B is f64 constant expresion (value known at compile time)
    -> (if decimal place of B is 0s, convert B i32, SUCCESS, else -> ERROR)

A is f64 constant expresion (value known at compile time) && B is i32 literal
    -> (Convert B to f64 -> SUCCESS)

A is i32 literal && B is f64 constant expresion (value known at compile time)
    -> (Convert A to f64 -> SUCCESS)

else:
    ERROR

> < <= >= (A opr B)

Not Allowed
A.nullable == true || B.nullable == true -> ERROR

Allowed # (same as for ==, !=)

A.type == B.type -> SUCESS

A is variable i32 && B is f64 literal
    -> (if deciaml place of B is 0s, convert B f64 -> SUCESS, else ERROR)

A is f64 literal && B is i32 variable
    -> (if decimal place of A is 0s, convert A f64 -> SUCCESS, else ERROR)

A is variable f64 && B is i32 literal
    -> (Convert B to f64 -> SUCCESS)

A is i32 literal && B is variable f64
    -> (Convert A to f64 -> SUCCESS)

A is f64 constant expresion (value known at compile time) && B is i32 variable
    -> (if decimal place of A is 0s, convert A i32, SUCCESS, else -> ERROR)

A is i32 variable && B is f64 constant expresion (value known at compile time)
    -> (if decimal place of B is 0s, convert B i32, SUCCESS, else -> ERROR)

A is f64 constant expresion (value known at compile time) && B is i32 literal
    -> (Convert B to f64 -> SUCCESS)

A is i32 literal && B is f64 constant expresion (value known at compile time)
    -> (Convert A to f64 -> SUCCESS)

else:
    ERROR

1.
binary tree:

         + -> in here, we have a (var, cannot be converted) and a binary expression, where the value is not know at compile time -> ERROR
        / \
var a: i32  + -> in here, the the return type: f64, and nullable: flase
           / \
          3.0  3


Proposed solution for constant expression

In symtable, when i declare a variable, i can add an optional argument (TOKEN_PTR)
which will be the value, this way i can check, if the value is known at compile time.
By default it will be set to NULL. to differentiate

What I need to know:

How does a "null" look like in the ast? is it:
 - IdentifierExpressionType
 - LiteralExpressionType 

 What are the values set to? when i get the struct -> Expression, what should i look for, to know, it is a 'null'?

 My solution?

 set it to be a type: LiteralExpressionType 
 set the struct -> Literal as follows
 .value = NULL;
 .data_type = dTypeNone;
 .is_nullable = true;

 Than i can differentiate, between internal errors, and null

How will i handle, coverting of constant expression types with know values? eg. const a = 3.0; ?

since each Expression can have the conversion flag, I can simply check it in the validator, and for each 
binary Expression, I can set conversion flags 


Handeling empty return:
Since your ast is composed of structs, and not pointers to strucs, we cannot set the struct to NULL,
However there is an eazy fix, instaid of -> 

typedef struct ReturnStatement {
    struct Expression value;
} ReturnStatement;

do -> 
typedef struct ReturnStatement {
    struct Expression value;
    bool empty;
} ReturnStatement;

The empty will be set by default to false, if there is nothing, set it to true

This will be the easiest for sem analysis, and for you as well, having only one check.


Other thoughs, I have not looked into it as much, but I did not see any stack of JMP adresses being used in while or ifStatement

I handled it like this

Stack 1 -> if statements
Stack 2 -> while loops

Ifs -> 
when entering an if, lets say you calulated the condtion, and saved it to var GF@bool_result
Generate a return adress (can be just numbers, for example we start at 1)
than you do
JMP if GF@bool_result != 1, jumpto -> if_else_1 [stack: 0: if_else_1]
..
if body
..
# here, you get the else, in the AST, what you do, is you generate another adress, here if_else_2, and paste it in
# stack: [stack: 0: if_else_1], geneerated_adress -> if_else_2
JMP if_else_2
# then you pop the last adress form the stack, here it would be if_else_1, and paste it in there
# [stack: NULL]
LABEL .if_else_1
# then you push the if_else_2 to the stack 
# [stack: 0: if_else_2]
...
else body
...
# here you get the end of the else, pop the last adress form the stack, and plonk it in
LABEL if_else_2
# [stack : NULL]

The beauty of this system, is that, you can have as many Ifs inside of each other, as you want, and it will never break
the stack can just hold one int value, and you can have a gloabl counter, to get the next adress
or just make an ADT (Abstract data type) for it

While loops

If you enter a while loop, in the AST, You cannot use DEFVAR, since if you define a variable two times, in the asempy code, you 
will get an error message

Solutions? 
1. well, you have created the AST, so you can first go through all the variables, defined in the while loop, and generate them beforehand
2. If you want to be brave, you can use the Local stack, for variables, but, well it will be harder, and 
if you have the AST, I would use it.

My old implemenations of while loops

# handle all the defvars, in the while loop here.
First, we create a new lable, for the while stacks and print it, but dont save it yet.
LABLE while_1
# [stack: NULL]
# here you handle the condition, I will assume, you have it in the GF@bool_result
# generate the 2nd adress, for me, it is while_2
# now we push while_2, and than push while_1
# [stack: 0: while_1, 1: while_2] 
# print out while_2 as the jump to cmd
JMP if bool_result == 0, jumpto -> while_2
...
while body
...
# here comes the end of the while, pop the first adresa and prit the jump
JMP while_1
# [stack: 0: while_2]
# pop the top item, and pritn lable
LABEL while_2
# [stack: NULL]

again, this is quite simple to do, and it will insure, it will allways workd, no matter how many whiles, you throw at it 

so while () {while () {whie() {}}} .. will also work, even with combinaions with if etc.

I had it as an ADT typedef struct ReturnAdressTracker {
    unsigned int if_count;
    unsigned int while_count;
    Stack if_stack;
    Stack while_stack;
}ReturnAdressTracker;

You can add you own functions, like pop_last_if_adress, add_if_adress, pop_last_while_adress, add_while_adress etc.

I am not telling you this, because i want to fee suppiriour, I just notised, that our code generation, is not gooad at the moment
so even doe, I have shown this to you, when you told me, You are mad, since I gave you a leacture. 
Here it is again, Do with it as you want.










